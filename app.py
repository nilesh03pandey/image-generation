import torch
from diffusers import FluxPipeline
from PIL import Image
import os
from flask import Flask, request, render_template, send_from_directory, jsonify, session
import uuid
import glob
import traceback
from datetime import timedelta

app = Flask(__name__)

# Secret key required for Flask sessions
app.secret_key = "super_secret_key_change_this"
app.permanent_session_lifetime = timedelta(hours=1)

# Set environment variable to avoid memory fragmentation
os.environ["PYTORCH_CUDA_ALLOC_CONF"] = "expandable_segments:True"

# Ensure static folder exists for saving images
STATIC_DIR = os.path.join(app.root_path, 'static')
os.makedirs(STATIC_DIR, exist_ok=True)


# -----------------------------
# Helpers
# -----------------------------

def _get_device_from_obj(obj):
    """Return device if obj or any nested item has a .device attribute."""
    try:
        if obj is None:
            return None
        if hasattr(obj, "device"):
            return obj.device
        if isinstance(obj, (tuple, list)):
            for item in obj:
                d = _get_device_from_obj(item)
                if d is not None:
                    return d
        if isinstance(obj, dict):
            for v in obj.values():
                d = _get_device_from_obj(v)
                if d is not None:
                    return d
    except Exception:
        return None
    return None


def get_session_dir():
    """Create a private static directory for each user session."""
    if "session_id" not in session:
        session["session_id"] = uuid.uuid4().hex
    session_dir = os.path.join(STATIC_DIR, session["session_id"])
    os.makedirs(session_dir, exist_ok=True)
    return session_dir


# -----------------------------
# Load pipeline once
# -----------------------------
try:
    pipe = FluxPipeline.from_pretrained(
        "black-forest-labs/FLUX.1-schnell",
        torch_dtype=torch.bfloat16
        
    )

    # Memory optimizations for RTX 3050
    pipe.enable_sequential_cpu_offload()
    pipe.enable_attention_slicing()

    # Debug hook
    def debug_device(module, input, output):
        dev = _get_device_from_obj(input) or _get_device_from_obj(output)
        try:
            if dev is None:
                params = list(module.parameters())
                if params:
                    dev = params[0].device
        except Exception:
            pass
        print(f"Active module ({module.__class__.__name__}) device: {dev}")

    if hasattr(pipe, "transformer") and pipe.transformer is not None:
        try:
            pipe.transformer.register_forward_hook(debug_device)
        except Exception as hook_e:
            print(f"Failed to register forward hook on transformer: {hook_e}")

    try:
        first_param = next(pipe.transformer.parameters())
        print("Initial model device:", first_param.device)
    except StopIteration:
        print("Transformer has no parameters.")
    except Exception as e:
        print(f"Error checking initial model device: {e}")

except Exception as e:
    print(f"Error loading pipeline: {str(e)}")
    raise


# -----------------------------
# Routes
# -----------------------------

@app.route('/', methods=['GET', 'POST'])
def index():
    image_url = None
    error = None
    prompt = ""  

    session_dir = get_session_dir()
    gallery_images = [
        f"/static/{session['session_id']}/{os.path.basename(f)}"
        for f in glob.glob(os.path.join(session_dir, "*.png"))
    ]

    if request.method == 'POST':
        prompt = request.form.get('prompt', '').strip()
        if not prompt:
            error = "Prompt cannot be empty."
        else:
            try:
                generator = torch.Generator(device="cpu").manual_seed(0)

                result = pipe(
                    prompt,
                    guidance_scale=1.0,
                    num_inference_steps=10,
                    max_sequence_length=512,
                    width=800,
                    height=800,
                    generator=generator
                )

                if not getattr(result, "images", None) or len(result.images) == 0:
                    raise ValueError("No images generated by pipeline")

                image = result.images[0]

                # Save image in user-specific folder
                image_filename = f"generated_{uuid.uuid4().hex}.png"
                image_path = os.path.join(session_dir, image_filename)
                image.save(image_path)

                image_url = f"/static/{session['session_id']}/{image_filename}"
                gallery_images.append(image_url)

            except Exception as e:
                error = f"Error generating image: {str(e)}"
                print(f"Detailed error: {traceback.format_exc()}")

    return render_template('index.html',
                           image_url=image_url,
                           prompt=prompt,
                           error=error,
                           gallery_images=gallery_images)


@app.route('/static/<session_id>/<filename>')
def serve_image(session_id, filename):
    """Serve only files from the user's session directory."""
    if "session_id" not in session or session["session_id"] != session_id:
        return "Unauthorized", 403
    return send_from_directory(os.path.join(STATIC_DIR, session_id), filename)


@app.route('/gallery')
def gallery():
    """Return gallery images only from current session directory."""
    session_dir = get_session_dir()
    gallery_images = [
        f"/static/{session['session_id']}/{os.path.basename(f)}"
        for f in glob.glob(os.path.join(session_dir, "*.png"))
    ]
    return jsonify({"images": gallery_images})


# -----------------------------
# Run
# -----------------------------
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
